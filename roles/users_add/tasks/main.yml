- name: Create groups for users
  ansible.builtin.group:
    name: "{{ item.username }}"
    state: present
  loop: "{{ users_add_userlist | default([]) }}"

- name: Create user accounts and force password change on first login
  ansible.builtin.user:
    name: "{{ item.username }}"
    state: present
    group: "{{ item.username }}"  # Ensures a group with the username is created/used as the primary group
    comment: "{{ item.username }} account. Is admin? {{ item.admin }}"
    shell: /bin/bash
    password: "{{ item.initialpassword | default(GENERALINITIALPASSWORD) | password_hash('sha512') }}"
      # Sets the initial password that is prompted to change at first ssh login with pubkey (only)
    update_password: on_create  # This ensures the password is only set when the user is created
  loop: "{{ users_add_userlist | default([]) }}"
  notify: Force password change on first login
  no_log: true  # Prevent password hashes from being logged

- name: Add additional public keys
  ansible.posix.authorized_key:
    key: "{{ item.public_key }}"
    user: "{{ item.username }}"
    state: present
    comment: "{{ item.username }} key"
  loop: "{{ users_add_userlist | default([]) }}"

- name: Add all users who should be admin to sudo
  ansible.builtin.lineinfile:
    path: "/etc/sudoers.d/{{ item.username }}"
    line: "{{ item.username }} ALL=(ALL) ALL"
    state: present
    mode: '0440'
    create: true
    validate: '/usr/sbin/visudo -cf %s'
  loop: "{{ users_add_userlist | default([]) }}"
  when: item.admin

- name: Allow non-admin users to run system updates/upgrades
  ansible.builtin.blockinfile:
    path: "/etc/sudoers.d/{{ item.username }}"
    block: |
      # ===================================================================
      # Limited sudo access for user: {{ item.username }}.
      # ===================================================================
      # 
      # This user is granted limited sudo privileges for system maintenance.
      # 
      # ALLOWED COMMANDS: {{ item.non_admin_allowed_commands }}
      #
      # To see this help again, run: sudo cat /etc/sudoers.d/{{ item.username }}
      # ===================================================================
      
      # Show lecture message on sudo use
      Defaults:{{ item.username }} lecture = always
      Defaults:{{ item.username }} lecture_file = /etc/sudoers.d/.{{ item.username }}_lecture
      
      # Actual sudo rules:
      {{ item.username }} ALL=(ALL) {{ item.non_admin_allowed_commands }}
    state: present
    create: true
    mode: '0440'
    validate: '/usr/sbin/visudo -cf %s'
  loop: "{{ users_add_userlist | default([]) }}"
  when:
    - not item.admin
    - item.non_admin_allowed_commands is defined
    - item.non_admin_allowed_commands | length > 0

- name: Create sudo lecture file for non-admin users
  ansible.builtin.copy:
    dest: "/etc/sudoers.d/.{{ item.username }}_lecture"
    content: |
      
      ===============================================================================
      NOTICE: Limited sudo access for {{ item.username }}. Abuse attempts are logged.
      ===============================================================================
      
      You have restricted sudo privileges. Your allowed commands are:
      {{ item.non_admin_allowed_commands }}
      
      Example usage:
        sudo apt update
        sudo apt upgrade
        sudo reboot
      
      ===============================================================================
      
    mode: '0644'
    owner: root
    group: root
  loop: "{{ users_add_userlist | default([]) }}"
  when:
    - not item.admin
    - item.non_admin_allowed_commands is defined
    - item.non_admin_allowed_commands | length > 0

- name: Set includedir in sudoers to make sure our additions work
  ansible.builtin.lineinfile:
    dest: /etc/sudoers
    line: "#includedir /etc/sudoers.d"
    state: present
    validate: "/usr/sbin/visudo -cf %s"

# ===================================================================
# MOTD SECURITY WARNINGS SECTION
# Add custom MOTD script to warn about pending updates and reboots
# ===================================================================

- name: Create simple CIS-compliant MOTD script (read-only)
  ansible.builtin.copy:
    dest: /etc/update-motd.d/95-security-warnings
    mode: '0444'
    content: |
      #!/bin/bash
      # Simple CIS-compliant MOTD script for security warnings
      # Content is generated by /usr/local/bin/update-security-status
      
      # Display pre-generated security status if available
      if [ -f /var/cache/motd-security-status ]; then
          cat /var/cache/motd-security-status
      else
          printf "\n=== SYSTEM SECURITY STATUS ===\n"
          printf "Security status: Checking...\n"
          printf "==============================\n\n"
      fi


- name: Ensure update-notifier-common is installed for reboot detection (Ubuntu only)
  ansible.builtin.package:
    name: update-notifier-common
    state: present
  failed_when: false  # Don't fail if package doesn't exist
  when: ansible_distribution == "Ubuntu"

- name: Create cache directory for MOTD security status
  ansible.builtin.file:
    path: /var/cache
    state: directory
    mode: '0755'
    owner: root
    group: root

- name: Create security status generator script
  ansible.builtin.copy:
    dest: /usr/local/bin/update-security-status
    mode: '0755'
    content: |
      #!/bin/bash
      # Script to generate security status for MOTD display
      # This script contains all the complex logic and generates a cache file
      
      # Output file for MOTD content
      OUTPUT_FILE="/var/cache/motd-security-status"
      TEMP_FILE="${OUTPUT_FILE}.tmp"
      
      # Colors for output
      RED='\033[0;31m'
      YELLOW='\033[1;33m'
      GREEN='\033[0;32m'
      NC='\033[0m' # No Color
      
      # Function to write to output
      write_output() {
          printf "$@" >> "$TEMP_FILE"
      }
      
      # Start generating content
      write_output "\n"
      write_output "=== SYSTEM SECURITY STATUS (updated hourly) ===\n"
      
      # Update package cache for accurate counts
      apt-get update >/dev/null 2>&1
      
      # Check for pending security updates
      if command -v apt-get >/dev/null 2>&1; then
          # Check for security updates
          SECURITY_UPDATES=$(apt-get -s upgrade 2>/dev/null | grep -i security | wc -l)
          TOTAL_UPDATES=$(apt list --upgradable 2>/dev/null | grep -c upgradable)
          
          if [ "$SECURITY_UPDATES" -gt 0 ]; then
              write_output "${RED}⚠️  WARNING: $SECURITY_UPDATES security updates pending!${NC}\n"
              write_output "${YELLOW}   Run: sudo apt update && sudo apt upgrade${NC}\n"
          elif [ "$TOTAL_UPDATES" -gt 0 ]; then
              write_output "${YELLOW}ℹ️  Info: $TOTAL_UPDATES package updates available${NC}\n"
          else
              write_output "${GREEN}✅ System packages are up to date${NC}\n"
          fi
      fi
      
      # Check for pending reboot
      REBOOT_REQUIRED=false
      REBOOT_REASON=""
      
      # Method 1: Check /var/run/reboot-required (Ubuntu with update-notifier-common)
      if [ -f /var/run/reboot-required ]; then
          REBOOT_REQUIRED=true
          REBOOT_REASON="System packages"
          if [ -f /var/run/reboot-required.pkgs ]; then
              write_output "${RED}🔄 WARNING: System reboot required!${NC}\n"
              write_output "${YELLOW}   Packages requiring reboot:${NC}\n"
              cat /var/run/reboot-required.pkgs | sed 's/^/     - /' >> "$TEMP_FILE"
          fi
      fi
      
      # Method 2: Check for kernel updates (works on most Linux distributions)
      RUNNING_KERNEL=$(uname -r)
      if [ -d /boot ]; then
          LATEST_KERNEL=$(ls /boot/vmlinuz-* 2>/dev/null | sed 's/.*vmlinuz-//' | sort -V | tail -1)
          if [ -n "$LATEST_KERNEL" ] && [ "$RUNNING_KERNEL" != "$LATEST_KERNEL" ]; then
              REBOOT_REQUIRED=true
              REBOOT_REASON="Kernel update (running: $RUNNING_KERNEL, available: $LATEST_KERNEL)"
          fi
      fi
      
      # Method 3: Check for process restarts needed (systemd systems)
      if command -v systemctl >/dev/null 2>&1; then
          NEEDS_RESTART=$(systemctl list-units --state=failed --no-legend 2>/dev/null | wc -l)
          if [ "${NEEDS_RESTART:-0}" -gt 0 ]; then
              REBOOT_REASON="${REBOOT_REASON:+$REBOOT_REASON, }Failed services detected"
          fi
      fi
      
      if [ "$REBOOT_REQUIRED" = true ]; then
          write_output "${RED}🔄 WARNING: System reboot required!${NC}\n"
          write_output "${YELLOW}   Reason: $REBOOT_REASON${NC}\n"
          write_output "${YELLOW}   Run: sudo reboot${NC}\n"
      else
          write_output "${GREEN}✅ No reboot required${NC}\n"
      fi
      
      # Check last reboot time with multiple fallback methods
      LAST_BOOT=""
      
      if [ -z "$LAST_BOOT" ] && command -v uptime >/dev/null 2>&1; then
          LAST_BOOT=$(uptime -s 2>/dev/null)
      fi
      
      # Fallback
      if [ -z "$LAST_BOOT" ]; then
          LAST_BOOT="unknown"
      fi
      
      write_output "ℹ️  Last boot: $LAST_BOOT\n"
      
      # Check system uptime
      UPTIME=$(uptime | awk -F'up ' '{print $2}' | awk -F', load' '{print $1}')
      write_output "ℹ️  Uptime: $UPTIME\n"
      
      write_output "==============================\n"
      write_output "\n"
      
      # Atomically move temp file to final location
      mv "$TEMP_FILE" "$OUTPUT_FILE"
      
      # Set proper permissions
      chmod 644 "$OUTPUT_FILE"
      
      # For Debian systems without update-motd, also update dynamic MOTD
      if ! command -v update-motd >/dev/null 2>&1; then
          cp "$OUTPUT_FILE" /var/run/motd.dynamic 2>/dev/null || true
      fi

- name: Create systemd service for MOTD security updates
  ansible.builtin.copy:
    dest: /etc/systemd/system/update-motd-security.service
    mode: '0644'
    content: |
      [Unit]
      Description=Update MOTD Security Status
      After=network.target
      
      [Service]
      Type=oneshot
      ExecStart=/usr/local/bin/update-security-status
      User=root
      
- name: Create systemd timer for MOTD security updates
  ansible.builtin.copy:
    dest: /etc/systemd/system/update-motd-security.timer
    mode: '0644'
    content: |
      [Unit]
      Description=Update MOTD Security Status Timer
      Requires=update-motd-security.service
      
      [Timer]
      OnCalendar=hourly
      Persistent=true
      
      [Install]
      WantedBy=timers.target
      
- name: Enable and start systemd timer for MOTD updates
  ansible.builtin.systemd:
    name: update-motd-security.timer
    enabled: true
    state: started
    daemon_reload: true

- name: Setup MOTD for Debian systems (different from Ubuntu)
  block:
    - name: Check if this is a Debian-based system without update-motd
      ansible.builtin.command: which update-motd
      register: update_motd_exists
      failed_when: false
      changed_when: false

    - name: Ensure PAM MOTD configuration for Ubuntu
      ansible.builtin.lineinfile:
        path: /etc/pam.d/sshd
        line: "session optional pam_motd.so motd=/run/motd.dynamic"
        insertafter: "# Print the message of the day upon successful login"
        state: present
      when: ansible_distribution == "Ubuntu" and update_motd_exists.rc != 0

    - name: Create PAM MOTD configuration for Debian
      ansible.builtin.lineinfile:
        path: /etc/pam.d/sshd
        line: "session optional pam_motd.so motd=/var/cache/motd-security-status"
        insertafter: "# Print the message of the day upon successful login"
        state: present
      become: true
      when: ansible_distribution == "Debian" and update_motd_exists.rc != 0

    - name: Generate initial security status and dynamic MOTD
      ansible.builtin.shell: /usr/local/bin/update-security-status
      when: update_motd_exists.rc != 0
      changed_when: false

    - name: Ensure cache file permissions
      ansible.builtin.file:
        path: /var/cache/motd-security-status
        owner: root
        group: root
        mode: '0644'
        state: touch
      when: update_motd_exists.rc != 0

  when: ansible_os_family == "Debian"

